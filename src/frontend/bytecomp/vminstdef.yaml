# ---------------------------------------------------
#   SATySFi virtual machine instruction definitions
# ---------------------------------------------------
#
# This is formatted according to the YAML.
#
# This file is read by `gen_code.rb`.
# `gen_code.rb` generates OCaml source code and
# type declarations for
#
# * `types.cppo.ml`,
# * `primitives.cppo.ml`,
# * `ir.cppo.ml`,
# * `evaluator.cppo.ml`, and
# * `vm.cppo.ml`.
#
#
# To add a new primitive,
#   1. Add a new instruction definition to this file.
#      (`is-pdf-mode-primitive` or `is-text-mode-primitive` should be yes.)
#   2. Add a new entry to primitives.ml.
#
#
# inst:          Instruction name (essential)
# is-pdf-mode-primitive:  Primitive for generating PDFs or not (default: no)
# is-text-mode-primitive: Primitive for generating texts or not (default: no)
# needs-reducef: Use `reducef` for evaluating applications (default: no)
# suppress-pp:   Use a simple pritty printer (default: no)
# custom-pp:     Specify custom pritty printer
# no-ircode:     Suppress code generation for `ir.ml` (default: no)
# no-interp:     Suppress code generation for `evaluator.ml` (default: !`is-pdf-mode-primitive`)
# name:          Identifier for the primitive
# type:          Type expression for the primitive
# fields:        Field list (for `abstract_tree` type)
# params:        Paramater list
# code:          Instruction code
#   (note: If `is-pdf-mode-primitive` or `is-text-mode-primitive` is yes, code that pushes to stack and
#          go to next instruction will be automatically inserted.
#          (see `gen_code.rb`))
#
---
inst: AccessField
fields:
- field_nm : field_name
params:
- value1
code: |
  match value1 with
  | RecordValue(asc1) ->
      begin
        match Assoc.find_opt asc1 field_nm with
        | Some(v) -> exec (v :: stack) env code dump
        | None    -> report_bug_vm ("AccessField field " ^ field_nm ^ " not found")
      end

  | _ -> report_bug_vm "not a Record"

---
inst: Forward
fields:
- n : int
code: |
  let (vs, stack) = popn stack n in
  match stack with
  | v0 :: stack ->
      exec (v0 :: List.rev_append vs stack) env code dump
  | _ ->
      report_bug_vm "Forward: stack underflow"

---
inst: Apply
fields:
- n : int
params:
- f
code: |
  match f with
  | CompiledFuncWithEnvironment(optvars, arity, pargs, framesize, body, env1) ->
      let body =
        optvars |> List.fold_left (fun acc optvar ->
          let bindop =
            match optvar with
            | GlobalVar(loc, evid, refs)    -> OpBindGlobal(loc, evid, !refs)
            | LocalVar(lv, off, evid, refs) -> OpBindLocal(lv, off, evid, !refs)
          in
            OpPush(Constructor("None", UnitConstant)) :: bindop :: acc
        ) body
      in
      if arity = n then
        begin
         if pargs = [] then
            exec stack (newframe env1 framesize) body ((env, code) :: dump)
          else
            let (args, stack) = popn stack n in
            let allargs = List.rev (pargs @ args) in
              exec (allargs @ stack) (newframe env1 framesize) body ((env, code) :: dump)
        end

      else if arity > n then
        let (args, stack) = popn stack n in
        let applied = CompiledFuncWithEnvironment([], arity - n, pargs @ args, framesize, body, env1) in
          exec (applied :: stack) env code dump

      else
        let (surplus, stack) = popn stack (n - arity) in
        let (args, stack) = popn stack arity in
        let allargs = List.rev (pargs @ args) in
          exec (allargs @ stack) (newframe env1 framesize) body ((env, OpInsertArgs(surplus) :: OpApply(n - arity) :: code) :: dump)

  | CompiledPrimitiveWithEnvironment(arity, [], framesize, body, env1, astf) ->
      if arity = n then
        exec stack (newframe env1 framesize) body ((env, code) :: dump)

      else if arity > n then
        let (args, stack) = popn stack n in
         let applied = CompiledFuncWithEnvironment([], arity - n, args, framesize, body, env1) in
           exec (applied :: stack) env code dump

      else
        let (surplus, stack) = popn stack (n - arity) in
          exec stack (newframe env1 framesize) body ((env, OpInsertArgs(surplus) :: OpApply(n - arity) :: code) :: dump)

   | _ ->
       report_bug_vm_value "Apply: not a function" f

---
inst: ApplyT
fields:
- n : int
params:
- f
code: |
  match f with
  | CompiledFuncWithEnvironment(optvars, arity, pargs, framesize, body, env1) ->
      let body =
        optvars |> List.fold_left (fun acc optvar ->
          let bindop =
            match optvar with
            | GlobalVar(loc, evid, refs)    -> OpBindGlobal(loc, evid, !refs)
            | LocalVar(lv, off, evid, refs) -> OpBindLocal(lv, off, evid, !refs)
          in
            OpPush(Constructor("None", UnitConstant)) :: bindop :: acc
        ) body
      in
      if arity = n then
        begin
         if pargs = [] then
            exec stack (newframe env1 framesize) body dump
          else
            let (args, stack) = popn stack n in
            let allargs = List.rev (pargs @ args) in
              exec (allargs @ stack) (newframe env1 framesize) body dump
        end

      else if arity > n then
        let (args, stack) = popn stack n in
        let applied = CompiledFuncWithEnvironment([], arity - n, pargs @ args, framesize, body, env1) in
          exec (applied :: stack) env code dump

      else
        let (surplus, stack) = popn stack (n - arity) in
        let (args, stack) = popn stack arity in
        let allargs = List.rev (pargs @ args) in
          exec (allargs @ stack) (newframe env1 framesize) body ((env, OpInsertArgs(surplus) :: OpApplyT(n - arity) :: code) :: dump)

   | CompiledPrimitiveWithEnvironment(arity, [], framesize, body, env1, astf) ->
       if arity = n then
         exec stack (newframe env1 framesize) body dump

       else if arity > n then
         let (args, stack) = popn stack n in
          let applied = CompiledFuncWithEnvironment([], arity - n, args, framesize, body, env1) in
            exec (applied :: stack) env code dump

       else
         let (surplus, stack) = popn stack (n-arity) in
           exec stack (newframe env1 framesize) body ((env, OpInsertArgs(surplus) :: OpApplyT(n - arity) :: code) :: dump)

   | _ ->
       report_bug_vm_value "ApplyT: not a function" f

---
inst: ApplyOptional
fields:
params:
- f
- v
code: |
  match f with
  | CompiledFuncWithEnvironment(var :: vars, arity, pargs, framesize, body, env1) ->
      let bindop =
        match var with
        | GlobalVar(loc, evid, refs)    -> OpBindGlobal(loc, evid, !refs)
        | LocalVar(lv, off, evid, refs) -> OpBindLocal(lv, off, evid, !refs)
      in
      let body = OpPush(Constructor("Some", v)) :: bindop :: body in
      let fnew = CompiledFuncWithEnvironment(vars, arity, pargs, framesize, body, env1) in
        exec (fnew :: stack) env code dump

  | _ ->
      report_bug_vm_value "ApplyOptional: not a function with optional arguments" f

---
inst: ApplyOmission
fields:
params:
- f
code: |
  match f with
  | CompiledFuncWithEnvironment(var :: vars, arity, pargs, framesize, body, env1) ->
      let bindop =
        match var with
        | GlobalVar(loc, evid, refs)    -> OpBindGlobal(loc, evid, !refs)
        | LocalVar(lv, off, evid, refs) -> OpBindLocal(lv, off, evid, !refs)
      in
      let body = OpPush(Constructor("None", UnitConstant)) :: bindop :: body in
      let fnew = CompiledFuncWithEnvironment(vars, arity, pargs, framesize, body, env1) in
        exec (fnew :: stack) env code dump

  | _ ->
      report_bug_vm_value "ApplyOmission: not a function with optional arguments" f

---
inst: BindGlobal
fields:
- loc : syntactic_value ref
- evid : EvalVarID.t
- refs : int
params:
- v
code: |
  loc := v;
  exec stack env code dump

---
inst: BindLocal
fields:
- lv : int
- offset : int
- evid : EvalVarID.t
- refs : int
params:
code: |
  match stack with
  | v :: stack ->
      local_set_value env lv offset v;
      exec stack env code dump

  | _ ->
      report_bug_vm ("BindLocal(" ^ (EvalVarID.show_direct evid) ^ ")")

---
inst: BindClosuresRec
fields:
- binds : (varloc * instruction list) list
code: |
  binds |> List.iter (fun (var, code) ->
    let recfunc = exec [] env code [] in
      match var with
      | GlobalVar(loc, evid, refs) -> loc := recfunc
      | LocalVar(lv, offset, evid, refs) -> local_set_value env lv offset recfunc
  );
  exec stack env code dump

---
inst: Branch
suppress-pp : yes
fields:
- body : instruction list
code: |
  exec stack env body dump

---
inst: BranchIf
suppress-pp : yes
fields:
- body : instruction list
params:
- b : bool
code: |
  if b then
    exec stack env body dump
  else
    exec stack env code dump

---
inst: BranchIfNot
suppress-pp : yes
fields:
- body : instruction list
params:
- b : bool
code: |
  if b then
    exec stack env code dump
  else
    exec stack env body dump

---
inst: LoadGlobal
custom-pp:
  (fun fmt (r, evid, refs) -> Format.fprintf fmt "OpLoadGlobal(%s)" (EvalVarID.show_direct evid))
fields:
- loc : syntactic_value ref
- evid : EvalVarID.t
- refs : int
code: |
  let v = !loc in
    exec (v :: stack) env code dump

---
inst: LoadLocal
fields:
- lv : int
- offset : int
- evid : EvalVarID.t
- refs : int
code: |
  let v = local_get_value env lv offset in
    exec (v :: stack) env code dump

---
inst: Dereference
is-pdf-mode-primitive: yes
no-interp: yes
params:
- valuecont
code: |
  match valuecont with
  | Location(stid) ->
      begin
        match find_location_value (vmenv_global env) stid with
        | Some(value) -> value
        | None        -> report_bug_vm "Dereference"
      end

  | _ ->
      report_bug_vm "Dereference"

---
inst: Dup
code: |
  let v =
    try List.hd stack with
    | Invalid_argument(_) -> report_bug_vm "Dup: stack underflow"
  in
    exec (v :: stack) env code dump

---
inst: Error
fields:
- msg : string
code: |
  raise (ExecError(msg))

---
inst: MakeConstructor
fields:
- ctor_nm : constructor_name
params:
- valuecont
code: |
  exec (Constructor(ctor_nm, valuecont) :: stack) env code dump

---
inst: MakeRecord
suppress-pp : yes
fields:
- keylst : Assoc.key list
code: |
  let rec collect keys asc st =
    match keys with
    | [] ->
        (asc, st)

    | k :: rest ->
        begin
          match st with
          | v :: stnew -> collect rest (Assoc.add asc k v) stnew
          | _          -> report_bug_vm "MakeRecord: stack underflow"
        end
    in
    let (asc, stack) = collect (List.rev keylst) Assoc.empty stack in
      exec (RecordValue(asc) :: stack) env code dump

---
inst: MakeTuple
fields:
- len : int
code: |
  let rec iter n last st =
    if n <= 0 then
      (last, st)
    else
      match st with
      | value :: stnew -> iter (n - 1) (TupleCons(value, last)) stnew
      | []             -> report_bug_vm "MakeTuple: stack underflow"
  in
  let (tuple, stack) = iter len EndOfTuple stack in
    exec (tuple :: stack) env code dump

---
inst: Pop
code: |
  let stack =
    try List.tl stack with
    | Invalid_argument(_) -> report_bug_vm "Pop: stack underflow"
  in
    exec stack env code dump

---
inst: Push
fields:
- v : syntactic_value
code: |
  exec (v :: stack) env code dump

---
inst: PushEnv
code: |
  exec (EvaluatedEnvironment(vmenv_global env) :: stack) env code dump

---
inst: CheckStackTopBool
suppress-pp : yes
fields:
- b : bool
- next : instruction list
params:
- v
code: |
  match v with
  | BooleanConstant(b0) when b = b0 -> exec stack env code dump
  | _                               -> exec stack env next dump

---
inst: CheckStackTopCtor
suppress-pp : yes
fields:
- ctor_nm : constructor_name
- next : instruction list
params:
- v
code: |
  match v with
  | Constructor(nm, sub) when nm = ctor_nm -> exec (sub :: stack) env code dump
  | _                                      -> exec stack env next dump

---
inst: CheckStackTopEndOfList
suppress-pp : yes
fields:
- next : instruction list
params:
- v
code: |
  match v with
  | EndOfList -> exec stack env code dump
  | _         -> exec stack env next dump

---
inst: CheckStackTopInt
suppress-pp : yes
fields:
- i : int
- next : instruction list
params:
- v
code: |
  match v with
  | IntegerConstant(i0) when i=i0 -> exec stack env code dump
  | _                             -> exec stack env next dump

---
inst: CheckStackTopListCons
suppress-pp : yes
fields:
- next : instruction list
params:
- v
code: |
  match v with
  | ListCons(car, cdr) -> exec (car :: cdr :: stack) env code dump
  | _                  -> exec stack env next dump

---
inst: CheckStackTopStr
suppress-pp : yes
fields:
- str : string
- next : instruction list
params:
- v
code: |
  match v with
  | StringConstant(s0) when s0 = str -> exec stack env code dump
  | _                                -> exec stack env next dump

---
inst: CheckStackTopTupleCons
suppress-pp : yes
fields:
- next : instruction list
params:
- v
code: |
  match v with
  | TupleCons(car, cdr) -> exec (car :: cdr :: stack) env code dump
  | _                   -> exec stack env next dump

---
inst: Closure
fields:
- optvars : varloc list
- arity : int
- framesize : int
- body : instruction list
code: |
  exec (CompiledFuncWithEnvironment(optvars, arity, [], framesize, body, env) :: stack) env code dump

---
inst: ClosureInputHorz
fields:
- imihlst : compiled_input_horz_element list
code: |
  let imihclos = exec_input_horz_content env imihlst in
    exec (imihclos :: stack) env code dump

---
inst: ClosureInputVert
fields:
- imivlst : compiled_input_vert_element list
code: |
  let imivclos = exec_input_vert_content env imivlst in
    exec (imivclos :: stack) env code dump

---
inst: BindLocationGlobal
fields:
- loc : syntactic_value ref
- evid : EvalVarID.t
params:
- valueini
code: |
  let stid = register_location (vmenv_global env) valueini in
  loc := Location(stid);
    exec stack env code dump

---
inst: BindLocationLocal
fields:
- lv : int
- offset : int
- evid : EvalVarID.t
params:
- valueini
code: |
  let stid = register_location (vmenv_global env) valueini in
  local_set_value env lv offset (Location(stid));
    exec stack env code dump

---
inst: UpdateGlobal
suppress-pp : yes
fields:
- loc : syntactic_value ref
- evid : EvalVarID.t
params:
- valuenew
code: |
   match !loc with
   | Location(stid) ->
       begin
         update_location (vmenv_global env) stid valuenew;
         exec (UnitConstant :: stack) env code dump
       end

   | _ -> report_bug_vm "UpdateGlobal"

---
inst: UpdateLocal
suppress-pp : yes
fields:
- lv : int
- offset : int
- evid : EvalVarID.t
params:
- valuenew
code: |
  match local_get_value env lv offset with
  | Location(stid) ->
       begin
         update_location (vmenv_global env) stid valuenew;
         exec (UnitConstant :: stack) env code dump
       end

  | _ -> report_bug_vm "UpdateLocal"

---
inst: Sel
fields:
- tpart : instruction list
- fpart : instruction list
suppress-pp: yes
params:
- b : bool
code: |
  if b then
    exec stack env tpart dump
  else
    exec stack env fpart dump

---
inst: Concat
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "^"
type: |
  ~% (tS @-> tS @-> tS)

params:
- value1
- value2
code: |
  match (value1, value2) with
  | (StringEmpty, _)                         -> value2
  | (_, StringEmpty)                         -> value1
  | (StringConstant(s1), StringConstant(s2)) -> StringConstant(s1 ^ s2)
  | _                                        -> report_bug_vm "Concat"

---
inst: PrimitiveSetMathVariantToChar
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "set-math-variant-char"
type: |
  ~% (tMCCLS @-> tI @-> tI @-> tCTX @-> tCTX)

params:
- mccls : math_char_class
- cpfrom : int
- cpto : int
- (ctx, valuecmd) : context
code: |
  let uchfrom = Uchar.of_int cpfrom in
  let uchto = Uchar.of_int cpto in
  let mcclsmap = ctx.HorzBox.math_variant_char_map in
    Context(HorzBox.({ ctx with
      math_variant_char_map = mcclsmap |> MathVariantCharMap.add (uchfrom, mccls) uchto;
    }), valuecmd)

---
inst: PrimitiveConvertStringForMath
is-pdf-mode-primitive: yes
name: "convert-string-for-math"
type: |
  ~% (tCTX @-> tMCCLS @-> tS @-> tS)

params:
- (ctx, valuecmd) : context
- mccls : math_char_class
- s : string
code:
  let ctx = HorzBox.({ ctx with math_char_class = mccls; }) in
  let (_, uchlst) = MathContext.convert_math_variant_char (ctx, valuecmd) s in
    StringConstant(InternalText.to_utf8 (InternalText.of_uchar_list uchlst))

---
inst: PrimitiveSetMathCommand
is-pdf-mode-primitive: yes
name: "set-math-command"
type: |
  ~% (tCMD @-> tCTX @-> tCTX)

params:
- valuecmd
- (ctx, _) : context
code: |
  Context(ctx, valuecmd)

---
inst: BackendMathVariantCharDirect
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-variant-char"
type: |
  ~% (tMATHCLS @-> tMCSTY @-> tMATH)

params:
- mathcls : math_class
- valuercd
code: |
  let is_big = false in  (* temporary *)
  let mvsty = get_math_variant_style valuercd in
    MathValue(HorzBox.([MathPure(MathVariantCharDirect(mathcls, is_big, mvsty))]))

---
inst: BackendGetLeftMathClass
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "get-left-math-class"
type: |
  ~% (tCTX @-> tMATH @-> tOPT tMATHCLS)

params:
- ictx : context
- mathlst : math
code: |
  match mathlst with
  | [] ->
      Constructor("None", UnitConstant)

  | math :: _ ->
      let mathcls = Math.get_left_math_kind ictx math in
        make_math_class_option_value mathcls

---
inst: BackendGetRightMathClass
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "get-right-math-class"
type: |
  ~% (tCTX @-> tMATH @-> tOPT tMATHCLS)

params:
- ictx : context
- mathlst : math
code: |
  match List.rev mathlst with
  | [] ->
      Constructor("None", UnitConstant)

  | math :: _ ->
      let mathcls = Math.get_right_math_kind ictx math in
        make_math_class_option_value mathcls

---
inst: BackendSpaceBetweenMaths
is-pdf-mode-primitive: yes
name: "space-between-maths"
type: |
  ~% (tCTX @-> tMATH @-> tMATH @-> tOPT tIB)

params:
- ictx : context
- mathlst1 : math
- mathlst2 : math
code: |
  let mathctx = MathContext.make ictx in
  let hbspaceopt = Math.space_between_maths mathctx mathlst1 mathlst2 in
    match hbspaceopt with
    | None          -> Constructor("None", UnitConstant)
    | Some(hbspace) -> Constructor("Some", Horz([hbspace]))

---
inst: BackendMathConcat
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-concat"
type: |
  ~% (tMATH @-> tMATH @-> tMATH)

params:
- mlst1 : math
- mlst2 : math
code: |
  MathValue(List.append mlst1 mlst2)

---
inst: BackendMathGroup
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-group"
type: |
  ~% (tMATHCLS @-> tMATHCLS @-> tMATH @-> tMATH)

params:
- mathcls1 : math_class
- mathcls2 : math_class
- mlst : math
code: |
  MathValue([MathGroup(mathcls1, mathcls2, mlst)])

---
inst: BackendMathSuperscript
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-sup"
type: |
  ~% (tMATH @-> tMATH @-> tMATH)

params:
- mlst1 : math
- mlst2 : math
code: |
  MathValue([MathSuperscript(mlst1, mlst2)])

---
inst: BackendMathSubscript
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-sub"
type: |
  ~% (tMATH @-> tMATH @-> tMATH)

params:
- mlst1 : math
- mlst2 : math
code: |
  MathValue([MathSubscript(mlst1, mlst2)])

---
inst: BackendMathFraction
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-frac"
type: |
  ~% (tMATH @-> tMATH @-> tMATH)

params:
- mlst1 : math
- mlst2 : math
code: |
  MathValue([MathFraction(mlst1, mlst2)])

---
inst: BackendMathRadical
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-radical"
type: |
  ~% (tOPT tMATH @-> tMATH @-> tMATH)

params:
- value1mopt
- mlst2 : math
code: |
  let mlst1opt = get_option get_math value1mopt in
  let radical = Primitives.default_radical in  (* temporary; should be variable *)
    match mlst1opt with
    | None        -> MathValue([MathRadical(radical, mlst2)])
    | Some(mlst1) -> MathValue([MathRadicalWithDegree(mlst1, mlst2)])

---
inst: BackendMathParen
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-paren"
type: |
  ~% (tPAREN @-> tPAREN @-> tMATH @-> tMATH)

needs-reducef: yes
params:
- valueparenL
- valueparenR
- mlst1 : math
code: |
  let parenL = make_paren reducef valueparenL in
  let parenR = make_paren reducef valueparenR in
    MathValue([MathParen(parenL, parenR, mlst1)])

---
inst: BackendMathParenWithMiddle
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-paren-with-middle"
type: |
  ~% (tPAREN @-> tPAREN @-> tPAREN @-> tL tMATH @-> tMATH)

needs-reducef: yes
params:
- valueparenL
- valueparenR
- valuemiddle
- mlstlst : math_list
code: |
  let parenL = make_paren reducef valueparenL in
  let parenR = make_paren reducef valueparenR in
  let middle = make_paren reducef valuemiddle in
    MathValue([MathParenWithMiddle(parenL, parenR, middle, mlstlst)])

---
inst: BackendMathUpperLimit
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-upper"
type: |
  ~% (tMATH @-> tMATH @-> tMATH)

params:
- mlst1 : math
- mlst2 : math
code: |
  MathValue([MathUpperLimit(mlst1, mlst2)])

---
inst: BackendMathLowerLimit
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-lower"
type: |
  ~% (tMATH @-> tMATH @-> tMATH)

params:
- mlst1 : math
- mlst2 : math
code: |
  MathValue([MathLowerLimit(mlst1, mlst2)])

---
inst: BackendMathPullInScripts
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-pull-in-scripts"
type: |
  ~% (tMATHCLS @-> tMATHCLS @-> (tOPT tMATH @-> tOPT tMATH @-> tMATH) @-> tMATH)

params:
- mathcls1 : math_class
- mathcls2 : math_class
- valuef
needs-reducef: yes
code: |
  let mlstf = make_pull_in_scripts reducef valuef in
  let mlst = [HorzBox.(MathPullInScripts(mathcls1, mathcls2, mlstf))] in
    MathValue(mlst)

---
inst: BackendMathChar
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-char"
type: |
  ~% (tMATHCLS @-> tS @-> tMATH)

params:
- mathcls : math_class
- uchlst : uchar_list
code: |
  let mlst = [HorzBox.(MathPure(MathElement(mathcls, MathChar(false, uchlst))))] in
    MathValue(mlst)

---
inst: BackendMathBigChar
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-big-char"
type: |
  ~% (tMATHCLS @-> tS @-> tMATH)

params:
- mathcls : math_class
- uchlst : uchar_list
code: |
  let mlst = [HorzBox.(MathPure(MathElement(mathcls, MathChar(true, uchlst))))] in
    MathValue(mlst)

---
inst: BackendMathCharWithKern
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-char-with-kern"
type: |
  let mckf = tLN @-> tLN @-> tLN in
    ~% (tMATHCLS @-> tS @-> mckf @-> mckf @-> tMATH)

needs-reducef: yes
params:
- mathcls : math_class
- uchlst : uchar_list
- valuekernfL
- valuekernfR
code: |
  let kernfL = make_math_char_kern_func reducef valuekernfL in
  let kernfR = make_math_char_kern_func reducef valuekernfR in
  let mlst = [HorzBox.(MathPure(MathElement(mathcls, MathCharWithKern(false, uchlst, kernfL, kernfR))))] in
    MathValue(mlst)

---
inst: BackendMathBigCharWithKern
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-big-char-with-kern"
type: |
  let mckf = tLN @-> tLN @-> tLN in
    ~% (tMATHCLS @-> tS @-> mckf @-> mckf @-> tMATH)

needs-reducef: yes
params:
- mathcls : math_class
- uchlst : uchar_list
- valuekernfL
- valuekernfR
code: |
  let kernfL = make_math_char_kern_func reducef valuekernfL in
  let kernfR = make_math_char_kern_func reducef valuekernfR in
  let mlst = [HorzBox.(MathPure(MathElement(mathcls, MathCharWithKern(true, uchlst, kernfL, kernfR))))] in
    MathValue(mlst)

---
inst: BackendMathText
is-pdf-mode-primitive: yes
name: "text-in-math"
type: |
  ~% (tMATHCLS @-> (tCTX @-> tIB) @-> tMATH)

needs-reducef: yes
params:
- mathcls : math_class
- valuef
code: |
  let hblstf ictx =
    let valueh = reducef valuef [Context(ictx)] in
      get_horz valueh
  in
    MathValue(HorzBox.([MathPure(MathElement(mathcls, MathEmbeddedText(hblstf)))]))

---
inst: BackendMathColor
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-color"
type: |
  ~% (tCLR @-> tMATH @-> tMATH)

params:
- color : color
- mlst : math
code: |
  MathValue(HorzBox.([MathChangeContext(MathChangeColor(color), mlst)]))

---
inst: BackendMathCharClass
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-char-class"
type: |
  ~% (tMCCLS @-> tMATH @-> tMATH)

params:
- mccls : math_char_class
- mlst : math
code: |
  MathValue(HorzBox.([MathChangeContext(MathChangeMathCharClass(mccls), mlst)]))

---
inst: BackendMathList
no-ircode: yes
fields:
- n : int
code: |
  let rec iter n st acc =
    if n <= 0 then
      (acc, st)
    else
      match st with
      | MathValue(m) :: stnew -> iter (n - 1) stnew (m :: acc)
      | _                     -> report_bug_vm "BackendMathList"
  in
  let (mlst, stack) = iter n stack [] in
    exec (MathValue(List.concat mlst) :: stack) env code dump

---
inst: BackendEmbeddedMath
is-pdf-mode-primitive: yes
name: "embed-math"
type: |
  ~% (tCTX @-> tMATH @-> tIB)

params:
- ictx : context
- mlst : math
code: |
  let mathctx = MathContext.make ictx in
  let hblst = Math.main mathctx mlst in
    Horz(hblst)

---
inst: BackendTabular
is-pdf-mode-primitive: yes
name: "tabular"
type: |
  ~% ((tL (tL tCELL)) @-> tRULESF @-> tIB)

needs-reducef : yes
params:
- valuetabular
- valuerulesf
code: |
  let tabular = get_list (get_list get_cell) valuetabular in
  let (imtabular, widlst, lenlst, wid, hgt, dpt) = Tabular.main tabular in
  let rulesf xs ys =
    let valuexs = make_length_list xs in
    let valueys = make_length_list ys in
    let valueret = reducef valuerulesf [valuexs; valueys] in
      graphics_of_list valueret
  in
    Horz(HorzBox.([HorzPure(PHGFixedTabular(wid, hgt, dpt, imtabular, widlst, lenlst, rulesf))]))

---
inst: BackendRegisterPdfImage
is-pdf-mode-primitive: yes
name: "load-pdf-image"
type: |
  ~% (tS @-> tI @-> tIMG)

params:
- srcpath : string
- pageno : int
code: |
  let imgkey = ImageInfo.add_pdf srcpath pageno in
    ImageKey(imgkey)

---
inst: BackendRegisterOtherImage
is-pdf-mode-primitive: yes
name: "load-image"
type: |
  ~% (tS @-> tIMG)

params:
- srcpath : string
code: |
  let imgkey = ImageInfo.add_image srcpath in
    ImageKey(imgkey)

---
inst: BackendUseImageByWidth
is-pdf-mode-primitive: yes
name: "use-image-by-width"
type: |
  ~% (tIMG @-> tLN @-> tIB)

params:
- valueimg
- wid : length
code: |
  match valueimg with
  | ImageKey(imgkey) ->
      let hgt = ImageInfo.get_height_from_width imgkey wid in
        Horz(HorzBox.([HorzPure(PHGFixedImage(wid, hgt, imgkey))]))

  | _ -> report_bug_vm "BackendUseImage"

---
inst: BackendHookPageBreak
is-pdf-mode-primitive: yes
name: "hook-page-break"
type: |
  ~% ((tPBINFO @-> tPT @-> tU) @-> tIB)

needs-reducef: yes
params:
- hookf
code: |
  let hookf = make_hook reducef hookf in
    Horz(HorzBox.([HorzPure(PHGHookPageBreak(hookf))]))

---
inst: Path
suppress-pp : yes
is-pdf-mode-primitive : yes
separated: yes
no-ircode: yes
no-interp: yes
fields:
- c_pathcomplst : ((instruction list) compiled_path_component) list
- c_cycleopt : (unit compiled_path_component) option
params:
- pt0 : point
code: |
  let (pathelemlst, closingopt) = get_path env c_pathcomplst c_cycleopt in
    PathValue([GeneralPath(pt0, pathelemlst, closingopt)])

---
inst: PathUnite
is-pdf-mode-primitive: yes
name: "unite-path"
type: |
  ~% (tPATH @-> tPATH @-> tPATH)

params:
- pathlst1 : path_value
- pathlst2 : path_value
code: |
  PathValue(List.append pathlst1 pathlst2)

---
inst: PathShift
is-pdf-mode-primitive: yes
name: "shift-path"
type: |
  ~% (tPT @-> tPATH @-> tPATH)

params:
- ptshift : point
- pathlst : path_value
code: |
  PathValue(List.map (shift_path ptshift) pathlst)

---
inst: PathGetBoundingBox
is-pdf-mode-primitive: yes
name: "get-path-bbox"
type: |
  ~% (tPATH @-> tPROD [tPT; tPT])

params:
- pathlst : path_value
code: |
  let (ptmin, ptmax) = get_path_list_bbox pathlst in
    TupleCons(make_point_value ptmin,
      TupleCons(make_point_value ptmax,
        EndOfTuple))

---
inst: PrePathBeginning
is-pdf-mode-primitive: yes
name: "start-path"
type: |
  ~% (tPT @-> tPRP)

params:
- pt0 : point
code: |
  PrePathValue(PrePath.start pt0)

---
inst: PrePathLineTo
is-pdf-mode-primitive: yes
name: "line-to"
type: |
  ~% (tPT @-> tPRP @-> tPRP)

params:
- pt1 : point
- prepath : prepath
code: |
  PrePathValue(prepath |> PrePath.line_to pt1)

---
inst: PrePathCubicBezierTo
is-pdf-mode-primitive: yes
name: "bezier-to"
type: |
  ~% (tPT @-> tPT @-> tPT @-> tPRP @-> tPRP)

params:
- ptS : point
- ptT : point
- pt1 : point
- prepath: prepath
code: |
  PrePathValue(prepath |> PrePath.bezier_to ptS ptT pt1)

---
inst: PrePathTerminate
is-pdf-mode-primitive: yes
name: "terminate-path"
type: |
  ~% (tPRP @-> tPATH)

params:
- prepath : prepath
code: |
  PathValue([prepath |> PrePath.terminate])

---
inst: PrePathCloseWithLine
is-pdf-mode-primitive: yes
name: "close-with-line"
type: |
  ~% (tPRP @-> tPATH)

params:
- prepath : prepath
code: |
  PathValue([prepath |> PrePath.close_with_line])

---
inst: PrePathCloseWithCubicBezier
is-pdf-mode-primitive: yes
name: "close-with-bezier"
type: |
  ~% (tPT @-> tPT @-> tPRP @-> tPATH)

params:
- ptS : point
- ptT : point
- prepath : prepath
code: |
  PathValue([prepath |> PrePath.close_with_bezier ptS ptT])

---
inst: HorzConcat
is-pdf-mode-primitive: yes
name: "++"
type: |
  ~% (tIB @-> tIB @-> tIB)

params:
- hblst1 : horz
- hblst2 : horz
code: |
  Horz(List.append hblst1 hblst2)

---
inst: VertConcat
is-pdf-mode-primitive: yes
name: "+++"
type: |
  ~% (tBB @-> tBB @-> tBB)

params:
- vblst1 : vert
- vblst2 : vert
code: |
  Vert(List.append vblst1 vblst2)

---
inst: HorzLex
is-pdf-mode-primitive: yes
name: "read-inline"
type: |
  ~% (tCTX @-> tIT @-> tIB)

separated: yes
params:
- valuectx
- value1
code: |
  match value1 with
  | CompiledInputHorzWithEnvironment(imihlst, envi) -> exec_pdf_mode_intermediate_input_horz envi valuectx imihlst
  | _                                               -> report_bug_vm "HorzLex"

code-interp: |
  match value1 with
  | InputHorzWithEnvironment(imihlst, envi) -> interpret_pdf_mode_intermediate_input_horz envi valuectx imihlst
  | _                                       -> report_bug_value "HorzLex" value1

---
inst: VertLex
is-pdf-mode-primitive: yes
name: "read-block"
type: |
  ~% (tCTX @-> tBT @-> tBB)

separated: yes
params:
- valuectx
- value1
code: |
  match value1 with
  | CompiledInputVertWithEnvironment(imivlst, envi) -> exec_pdf_mode_intermediate_input_vert envi valuectx imivlst
  | _                                               -> report_bug_vm "VertLex"

code-interp: |
  match value1 with
  | InputVertWithEnvironment(imivlst, envi) -> interpret_pdf_mode_intermediate_input_vert envi valuectx imivlst
  | _                                       -> report_bug_value "VertLex" value1

---
inst: TextHorzLex
is-text-mode-primitive: yes
name: "stringify-inline"
type: |
  ~% (tTCTX @-> tIT @-> tS)

separated: yes
params:
- valuetctx
- value1
code: |
  match value1 with
  | CompiledInputHorzWithEnvironment(imihlst, envi) -> exec_text_mode_intermediate_input_horz envi valuetctx imihlst
  | _                                               -> report_bug_vm "TextHorzLex"

code-interp: |
  match value1 with
  | InputHorzWithEnvironment(imihlst, envi) -> interpret_text_mode_intermediate_input_horz envi valuetctx imihlst
  | _                                       -> report_bug_value "TextHorzLex" value1

---
inst: TextVertLex
is-text-mode-primitive: yes
name: "stringify-block"
type: |
  ~% (tTCTX @-> tBT @-> tS)

separated: yes
params:
- valuetctx
- value1
code: |
  match value1 with
  | CompiledInputVertWithEnvironment(imivlst, envi) -> exec_text_mode_intermediate_input_vert envi valuetctx imivlst
  | _                                               -> report_bug_vm "TextVertLex"

code-interp: |
  match value1 with
  | InputVertWithEnvironment(imivlst, envi) -> interpret_text_mode_intermediate_input_vert envi valuetctx imivlst
  | _                                       -> report_bug_value "TextVertLex" value1

---
inst: TextDeepenIndent
is-text-mode-primitive: yes
name: "deepen-indent"
type: |
  ~% (tI @-> tTCTX @-> tTCTX)

params:
- i : int
- tctx : text_mode_context
code: |
  let tctx = tctx |> TextBackend.deepen_indent i in
    TextModeContext(tctx)

---
inst: TextBreak
is-text-mode-primitive: yes
name: "break"
params:
- tctx : text_mode_context
type: |
  ~% (tTCTX @-> tS)

code: |
  let i = TextBackend.get_indent tctx in
  let s = "\n" ^ (String.make i ' ') in
    StringConstant(s)

---
inst: TextGetInitialTextModeContext
is-text-mode-primitive: yes
name: "get-initial-text-info"
params:
- value1
type: |
  ~% (tU @-> tTCTX)

code: |
  match value1 with
  | UnitConstant ->
      let tctx = TextBackend.get_initial_text_mode_context () in
        TextModeContext(tctx)

  | _ ->
      report_bug_value "TextGetInitialTextModeContext" value1

---
inst: PrimitiveEmbeddedVertBreakable
is-pdf-mode-primitive: yes
name: "embed-block-breakable"
type: |
  ~% (tCTX @-> tBB @-> tIB)

params:
- (ctx, _) : context
- vblst : vert
code: |
  let wid = ctx.HorzBox.paragraph_width in
    Horz([HorzEmbeddedVertBreakable(wid, vblst)])

---
inst: BackendFont
is-pdf-mode-primitive: yes
params:
- abbrev : string
- size_ratio : float
- rising_ratio : float
code: |
  make_font_value (abbrev, size_ratio, rising_ratio)

---
inst: BackendLineBreaking
is-pdf-mode-primitive: yes
name: "line-break"
type: |
  ~% (tB @-> tB @-> tCTX @-> tIB @-> tBB)

params:
- is_breakable_top : bool
- is_breakable_bottom : bool
- (ctx,  _) : context
- hblst : horz
code: |
  let imvblst = HorzBox.(LineBreak.main is_breakable_top is_breakable_bottom ctx.paragraph_top ctx.paragraph_bottom ctx hblst) in
    Vert(imvblst)

---
inst: BackendPageBreaking
is-pdf-mode-primitive: yes
name: "page-break"
type: |
  ~% (tPG @-> tPAGECONTF @-> tPAGEPARTSF @-> tBB @-> tDOC)

needs-reducef: yes
params:
- pagesize : page_size
- valuepagecontf
- valuepagepartsf
- vblst : vert
code: |
  let pagecontf = make_page_content_scheme_func reducef valuepagecontf in
  let pagepartsf = make_page_parts_scheme_func reducef valuepagepartsf in
    DocumentValue(pagesize, pagecontf, pagepartsf, vblst)

---
inst: BackendVertFrame
is-pdf-mode-primitive: yes
name: "block-frame-breakable"
type: |
  ~% (tCTX @-> tPADS @-> tDECOSET @-> (tCTX @-> tBB) @-> tBB)

needs-reducef : yes
params:
- (ctx, valuecmd) : context
- pads : paddings
- (valuedecoS, valuedecoH, valuedecoM, valuedecoT) : decoset
- valuek
code: |
  let valuectxsub =
    Context(HorzBox.({ ctx with
      paragraph_width = HorzBox.(ctx.paragraph_width -% pads.paddingL -% pads.paddingR);
    }), valuecmd)
  in
  let vblst =
    let valuev = reducef valuek [valuectxsub] in
      get_vert valuev
  in
    Vert(HorzBox.([
      VertTopMargin(true, ctx.paragraph_top);
      VertFrame(pads,
                  make_frame_deco reducef valuedecoS,
                  make_frame_deco reducef valuedecoH,
                  make_frame_deco reducef valuedecoM,
                  make_frame_deco reducef valuedecoT,
                  ctx.paragraph_width, vblst);
      VertBottomMargin(true, ctx.paragraph_bottom);
  ]))

---
inst: BackendAddFootnote
is-pdf-mode-primitive: yes
name: "add-footnote"
type: |
  ~% (tBB @-> tIB)

params:
- vblst : vert
code: |
  let imvblst = PageBreak.solidify vblst in
    Horz(HorzBox.([HorzPure(PHGFootnote(imvblst))]))

---
inst: BackendEmbeddedVertTop
is-pdf-mode-primitive: yes
name: "embed-block-top"
type: |
  ~% (tCTX @-> tLN @-> (tCTX @-> tBB) @-> tIB)

needs-reducef : yes
params:
- (ctx, valuecmd) : context
- wid : length
- valuek
code: |
  let valuectxsub =
    Context(HorzBox.({ ctx with paragraph_width = wid; }), valuecmd)
  in
  let vblst =
    let valuev = reducef valuek [valuectxsub] in
      get_vert valuev
  in
  let imvblst = PageBreak.solidify vblst in
  let (hgt, dpt) = PageBreak.adjust_to_first_line imvblst in
    Horz(HorzBox.([HorzPure(PHGEmbeddedVert(wid, hgt, dpt, imvblst))]))

---
inst: BackendVertSkip
is-pdf-mode-primitive: yes
name: "block-skip"
type: |
  ~% (tLN @-> tBB)

params:
- len : length
code: |
  Vert(HorzBox.([VertFixedBreakable(len)]))

---
inst: BackendEmbeddedVertBottom
is-pdf-mode-primitive: yes
name: "embed-block-bottom"
type: |
  ~% (tCTX @-> tLN @-> (tCTX @-> tBB) @-> tIB)

needs-reducef : yes
params:
- (ctx, valuecmd) : context
- wid : length
- valuek
code: |
  let valuectxsub =
    Context(HorzBox.({ ctx with paragraph_width = wid; }), valuecmd)
  in
  let vblst =
    let valuev = reducef valuek [valuectxsub] in
      get_vert valuev
  in
  let imvblst = PageBreak.solidify vblst in
  let (hgt, dpt) = PageBreak.adjust_to_last_line imvblst in
    Horz(HorzBox.([HorzPure(PHGEmbeddedVert(wid, hgt, dpt, imvblst))]))

---
inst: BackendLineStackTop
is-pdf-mode-primitive: yes
name: "line-stack-top"
type: |
  ~% ((tL tIB) @-> tIB)

params:
- valuehblstlst
code: |
  let hblstlst = get_list get_horz valuehblstlst in
  let (wid, vblst) = make_line_stack hblstlst in
  let imvblst = PageBreak.solidify vblst in
  let (hgt, dpt) = PageBreak.adjust_to_first_line imvblst in
    Horz(HorzBox.([HorzPure(PHGEmbeddedVert(wid, hgt, dpt, imvblst))]))

---
inst: BackendLineStackBottom
is-pdf-mode-primitive: yes
name: "line-stack-bottom"
type: |
  ~% ((tL tIB) @-> tIB)

params:
- valuehblstlst
code: |
  let hblstlst = get_list get_horz valuehblstlst in
  let (wid, vblst) = make_line_stack hblstlst in
  let imvblst = PageBreak.solidify vblst in
  let (hgt, dpt) = PageBreak.adjust_to_last_line imvblst in
    Horz(HorzBox.([HorzPure(PHGEmbeddedVert(wid, hgt, dpt, imvblst))]))

---
inst: PrimitiveGetInitialContext
is-pdf-mode-primitive: yes
name: "get-initial-context"
type: |
  ~% (tLN @-> tCMD @-> tCTX)

params:
- txtwid : length
- valuecmd
code: |
  let ctx = Primitives.get_pdf_mode_initial_context txtwid in
    Context(ctx, valuecmd)

---
inst: PrimitiveSetHyphenMin
is-pdf-mode-primitive: yes
name: "set-hyphen-min"
type: |
  ~% (tI @-> tI @-> tCTX @-> tCTX)

params:
- lmin : int
- rmin : int
- (ctx, valuecmd) : context
code: |
  Context(HorzBox.({ ctx with
    left_hyphen_min = max 0 lmin;
    right_hyphen_min = max 0 rmin;
  }), valuecmd)

---
inst: PrimitiveSetMinGapOfLines
is-pdf-mode-primitive: yes
name: "set-min-gap-of-lines"
type: |
  ~% (tLN @-> tCTX @-> tCTX)

params:
- lengap : length
- (ctx, valuecmd) : context
code: |
  Context(HorzBox.({ ctx with
    min_gap_of_lines = Length.max Length.zero lengap;
  }), valuecmd)

---
inst: PrimitiveSetSpaceRatio
is-pdf-mode-primitive: yes
name: "set-space-ratio"
type: |
  ~% (tFL @-> tFL @-> tFL @-> tCTX @-> tCTX)

params:
- ratio_natural : float
- ratio_shrink : float
- ratio_stretch : float
- (ctx, valuecmd) : context
code: |
  Context(HorzBox.({ ctx with
    space_natural = max 0. ratio_natural;
    space_shrink  = max 0. ratio_shrink;
    space_stretch = max 0. ratio_stretch;
  }), valuecmd)

---
inst: PrimitiveSetSpaceRatioBetweenScripts
is-pdf-mode-primitive: yes
name: "set-space-ratio-between-scripts"
type: |
  ~% (tFL @-> tFL @-> tFL @-> tSCR @-> tSCR @-> tCTX @-> tCTX)

params:
- ratio_natural : float
- ratio_shrink : float
- ratio_stretch : float
- script1 : script
- script2 : script
- (ctx, valuecmd) : context
code: |
  Context(HorzBox.({ ctx with
    script_space_map =
      ctx.script_space_map |> CharBasis.ScriptSpaceMap.add
        (script1, script2)
        (max 0. ratio_natural, max 0. ratio_shrink, max 0. ratio_stretch)
  }), valuecmd)

---
inst: PrimitiveGetSpaceRatioBetweenScripts
is-pdf-mode-primitive: yes
name: "get-space-ratio-between-scripts"
type: |
  ~% (tCTX @-> tSCR @-> tSCR @-> tOPT (tPROD [tFL; tFL; tFL]))

params:
- (ctx, _) : context
- script1 : script
- script2 : script
code: |
  match ctx.script_space_map |> CharBasis.ScriptSpaceMap.find_opt (script1, script2) with
  | None ->
      Constructor("None", UnitConstant)

  | Some((r0, r1, r2)) ->
      Constructor("Some", TupleCons(FloatConstant(r0),
                            TupleCons(FloatConstant(r1),
                              TupleCons(FloatConstant(r2), EndOfTuple))))

---
inst: PrimitiveSetParagraphMargin
is-pdf-mode-primitive: yes
name: "set-paragraph-margin"
type: |
  ~% (tLN @-> tLN @-> tCTX @-> tCTX)

params:
- lentop : length
- lenbottom : length
- (ctx, valuecmd) : context
code: |
  Context(HorzBox.({ ctx with
    paragraph_top    = lentop;
    paragraph_bottom = lenbottom;
  }), valuecmd)

---
inst: PrimitiveSetParagraphMinAscenderAndDescender
is-pdf-mode-primitive: yes
name: "set-min-paragraph-ascender-and-descender"
type: |
  ~% (tLN @-> tLN @-> tCTX @-> tCTX)

params:
- lenminasc : length
- lenmindesc : length
- (ctx, valuecmd) : context
code: |
  Context(HorzBox.({ ctx with
    min_first_line_ascender = lenminasc;
    min_last_line_descender = lenmindesc;
  }), valuecmd)

---
inst: PrimitiveSetFontSize
is-pdf-mode-primitive: yes
name: "set-font-size"
type: |
  ~% (tLN @-> tCTX @-> tCTX)

params:
- size : length
- (ctx, valuecmd) : context
code: |
  Context(HorzBox.({ ctx with font_size = size; }), valuecmd)

---
inst: PrimitiveGetFontSize
is-pdf-mode-primitive: yes
name: "get-font-size"
type: |
  ~% (tCTX @-> tLN)

params:
- (ctx, _) : context
code: |
  LengthConstant(ctx.HorzBox.font_size)

---
inst: PrimitiveSetFont
is-pdf-mode-primitive: yes
name: "set-font"
type: |
  ~% (tSCR @-> tFONT @-> tCTX @-> tCTX)

params:
- script : script
- font_info : font
- (ctx, valuecmd) : context
code: |
  let font_scheme_new = HorzBox.(ctx.font_scheme |> CharBasis.ScriptSchemeMap.add script font_info) in
    Context(HorzBox.({ ctx with font_scheme = font_scheme_new; }), valuecmd)

---
inst: PrimitiveGetFont
is-pdf-mode-primitive: yes
name: "get-font"
type: |
  ~% (tSCR @-> tCTX @-> tFONT)

params:
- script : script
- (ctx, _) : context
code: |
  let fontwr = HorzBox.get_font_with_ratio ctx script in
    make_font_value fontwr

---
inst: PrimitiveSetMathFont
is-pdf-mode-primitive: yes
name: "set-math-font"
type: |
  ~% (tS @-> tCTX @-> tCTX)

params:
- mfabbrev : string
- (ctx, valuecmd) : context
code: |
  Context(HorzBox.({ ctx with math_font = mfabbrev; }), valuecmd)

---
inst: PrimitiveSetDominantWideScript
is-pdf-mode-primitive: yes
name: "set-dominant-wide-script"
type: |
  ~% (tSCR @-> tCTX @-> tCTX)

params:
- script: script
- (ctx, valuecmd) : context
code: |
  Context(HorzBox.({ ctx with dominant_wide_script = script; }), valuecmd)

---
inst: PrimitiveGetDominantWideScript
is-pdf-mode-primitive: yes
name: "get-dominant-wide-script"
type: |
  ~% (tCTX @-> tSCR)

params:
- (ctx, _) : context
code: |
  make_script_value ctx.HorzBox.dominant_wide_script

---
inst: PrimitiveSetDominantNarrowScript
is-pdf-mode-primitive: yes
name: "set-dominant-narrow-script"
type: |
  ~% (tSCR @-> tCTX @-> tCTX)

params:
- script : script
- (ctx, valuecmd) : context
code: |
  Context(HorzBox.({ ctx with dominant_narrow_script = script; }), valuecmd)

---
inst: PrimitiveGetDominantNarrowScript
is-pdf-mode-primitive: yes
name: "get-dominant-narrow-script"
type: |
  ~% (tCTX @-> tSCR)

params:
- (ctx, _) : context
code: |
  make_script_value ctx.HorzBox.dominant_narrow_script

---
inst: PrimitiveSetLangSys
is-pdf-mode-primitive: yes
name: "set-language"
type: |
  ~% (tSCR @-> tLANG @-> tCTX @-> tCTX)

params:
- script : script
- langsys : language_system
- (ctx, valuecmd) : context
code: |
  Context(HorzBox.({ ctx with
    langsys_scheme = ctx.langsys_scheme |> CharBasis.ScriptSchemeMap.add script langsys;
  }), valuecmd)

---
inst: PrimitiveGetLangSys
is-pdf-mode-primitive: yes
name: "get-language"
type: |
  ~% (tSCR @-> tCTX @-> tLANG)

params:
- script : script
- (ctx, _) : context
code: |
  let langsys = HorzBox.get_language_system ctx script in
    make_language_system_value langsys

---
inst: PrimitiveSetTextColor
is-pdf-mode-primitive: yes
name: "set-text-color"
type: |
  ~% (tCLR @-> tCTX @-> tCTX)

params:
- color : color
- (ctx, valuecmd) : context
code: |
  Context(HorzBox.({ ctx with text_color = color; }), valuecmd)

---
inst: PrimitiveGetTextColor
is-pdf-mode-primitive: yes
name: "get-text-color"
type: |
  ~% (tCTX @-> tCLR)

params:
- (ctx, _) : context
code: |
  let color = ctx.HorzBox.text_color in
    make_color_value color

---
inst: PrimitiveSetLeading
is-pdf-mode-primitive: yes
name: "set-leading"
type: |
  ~% (tLN @-> tCTX @-> tCTX)

params:
- len : length
- (ctx, valuecmd) : context
code: |
  Context(HorzBox.({ ctx with leading = len; }), valuecmd)

---
inst: PrimitiveGetTextWidth
is-pdf-mode-primitive: yes
name: "get-text-width"
type: |
  ~% (tCTX @-> tLN)

params:
- (ctx, _) : context
code: |
  LengthConstant(ctx.HorzBox.paragraph_width)

---
inst: PrimitiveSetManualRising
is-pdf-mode-primitive: yes
name: "set-manual-rising"
type: |
  ~% (tLN @-> tCTX @-> tCTX)

params:
- rising : length
- (ctx, valuecmd) : context
code: |
  Context(HorzBox.({ ctx with manual_rising = rising; }), valuecmd)

---
inst: PrimitiveRaise
is-pdf-mode-primitive: yes
name: "raise-inline"
type: |
  ~% (tLN @-> tIB @-> tIB)

params:
- rising : length
- hblst : horz
code: |
  Horz(HorzBox.([HorzPure(PHGRising(rising, hblst))]))

---
inst: PrimitiveSetHyphenPenalty
is-pdf-mode-primitive: yes
name: "set-hyphen-penalty"
type: |
  ~% (tI @-> tCTX @-> tCTX)

params:
- pnlty : int
- (ctx, valuecmd) : context
code: |
  Context(HorzBox.({ ctx with hyphen_badness = pnlty; }), valuecmd)

---
inst: PrimitiveEmbed
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "embed-string"
type: |
  ~% (tS @-> tIT)

separated: yes
params:
- str : string
code: |
  CompiledInputHorzWithEnvironment([CompiledImInputHorzText(str)], env)

code-interp: |
  InputHorzWithEnvironment([ImInputHorzText(str)], env)

---
inst: PrimitiveExtract
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "extract-string"
type: |
  ~% (tIB @-> tS)
params:
  - hblst : horz
code: |
  StringConstant(HorzBox.extract_string hblst)

---
inst: PrimitiveGetAxisHeight
is-pdf-mode-primitive: yes
name: "get-axis-height"
type: |
  ~% (tCTX @-> tLN)

params:
- (ctx, _) : context
code: |
  let fontsize = ctx.HorzBox.font_size in
  let mfabbrev = ctx.HorzBox.math_font in
  let hgt = FontInfo.get_axis_height mfabbrev fontsize in
    LengthConstant(hgt)

---
inst: BackendFixedEmpty
is-pdf-mode-primitive: yes
name: "inline-skip"
type: |
  ~% (tLN @-> tIB)

params:
- wid : length
code: |
  Horz([HorzBox.HorzPure(HorzBox.PHSFixedEmpty(wid))])

---
inst: BackendOuterEmpty
is-pdf-mode-primitive: yes
name: "inline-glue"
type: |
  ~% (tLN @-> tLN @-> tLN @-> tIB)

params:
- widnat : length
- widshrink : length
- widstretch : length
code: |
  Horz([HorzBox.HorzPure(HorzBox.PHSOuterEmpty(widnat, widshrink, widstretch))])

---
inst: BackendOuterFrame
is-pdf-mode-primitive: yes
name: "inline-frame-outer"
type: |
  ~% (tPADS @-> tDECO @-> tIB @-> tIB)

needs-reducef: yes
params:
- pads : paddings
- valuedeco
- hblst : horz
code: |
  Horz([HorzBox.HorzPure(HorzBox.PHGOuterFrame(
    pads,
    make_frame_deco reducef valuedeco,
    hblst))])

---
inst: BackendInnerFrame
is-pdf-mode-primitive: yes
name: "inline-frame-inner"
type: |
  ~% (tPADS @-> tDECO @-> tIB @-> tIB)

needs-reducef: yes
params:
- pads : paddings
- valuedeco
- hblst : horz
code: |
  Horz([HorzBox.HorzPure(HorzBox.PHGInnerFrame(
    pads,
    make_frame_deco reducef valuedeco,
    hblst))])

---
inst: BackendFixedFrame
is-pdf-mode-primitive: yes
name: "inline-frame-fixed"
type: |
  ~% (tLN @-> tPADS @-> tDECO @-> tIB @-> tIB)

needs-reducef: yes
params:
- wid : length
- pads : paddings
- valuedeco
- hblst : horz
code: |
  Horz([HorzBox.HorzPure(HorzBox.PHGFixedFrame(
    pads, wid,
    make_frame_deco reducef valuedeco,
    hblst))])

---
inst: BackendOuterFrameBreakable
is-pdf-mode-primitive: yes
name: "inline-frame-breakable"
type: |
  ~% (tPADS @-> tDECOSET @-> tIB @-> tIB)

needs-reducef: yes
params:
- pads : paddings
- (valuedecoS, valuedecoH, valuedecoM, valuedecoT) : decoset
- hblst : horz
code: |
  Horz([HorzBox.HorzFrameBreakable(
    pads, Length.zero, Length.zero,
    make_frame_deco reducef valuedecoS,
    make_frame_deco reducef valuedecoH,
    make_frame_deco reducef valuedecoM,
    make_frame_deco reducef valuedecoT,
    hblst
  )])

---
inst: BackendInlineGraphics
is-pdf-mode-primitive: yes
name: "inline-graphics"
type: |
  ~% (tLN @-> tLN @-> tLN @-> tIGR @-> tIB)

needs-reducef: yes
params:
- wid : length
- hgt : length
- dpt : length
- valueg
code: |
  let graphics = make_inline_graphics reducef valueg in
    Horz(HorzBox.([HorzPure(PHGFixedGraphics(wid, hgt, Length.negate dpt, graphics))]))

---
inst: BackendInlineGraphicsOuter
is-pdf-mode-primitive: yes
name: "inline-graphics-outer"
type: |
  ~% (tLN @-> tLN @-> tIGRO @-> tIB)

needs-reducef: yes
params:
- hgt : length
- dpt : length
- valueg
code: |
  let graphics = make_inline_graphics_outer reducef valueg in
    Horz(HorzBox.([HorzPure(PHGOuterFilGraphics(hgt, Length.negate dpt, graphics))]))

---
inst: BackendScriptGuard
is-pdf-mode-primitive: yes
name: "script-guard"
type: |
  ~% (tSCR @-> tIB @-> tIB)

params:
- script : script
- hblst : horz
code: |
  Horz(HorzBox.([HorzScriptGuard(script, hblst)]))

---
inst: BackendDiscretionary
is-pdf-mode-primitive: yes
name: "discretionary"
type: |
  ~% (tI @-> tIB @-> tIB @-> tIB @-> tIB)

params:
- pb : int
- hblst0 : horz
- hblst1 : horz
- hblst2 : horz
code: |
  Horz(HorzBox.([HorzDiscretionary(pb, hblst0, hblst1, hblst2)]))

---
inst: BackendRegisterCrossReference
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "register-cross-reference"
type: |
  ~% (tS @-> tS @-> tU)

params:
- k : string
- v : string
code: |
  CrossRef.register k v;
  UnitConstant

---
inst: BackendGetCrossReference
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "get-cross-reference"
type: |
  ~% (tS @-> (tOPT tS))

params:
- k : string
code: |
  match CrossRef.get k with
  | None    -> Constructor("None", UnitConstant)
  | Some(v) -> Constructor("Some", StringConstant(v))

---
inst: PrimitiveGetNaturalMetrics
is-pdf-mode-primitive: yes
name: "get-natural-metrics"
type: |
  ~% (tIB @-> tPROD [tLN; tLN; tLN])

params:
- hblst : horz
code: |
  let (wid, hgt, dpt) = LineBreak.get_natural_metrics hblst in
    TupleCons(LengthConstant(wid),
      TupleCons(LengthConstant(hgt),
        TupleCons(LengthConstant(Length.negate dpt), EndOfTuple)))

---
inst: PrimitiveGetNaturalLength
is-pdf-mode-primitive: yes
name: "get-natural-length"
type: |
  ~% (tBB @-> tLN)

params:
- vblst : vert
code: |
  let imvblst = PageBreak.solidify vblst in
  let (hgt, dpt) = PageBreak.adjust_to_first_line imvblst in
    LengthConstant(hgt +% (Length.negate dpt))

---
inst: PrimitiveDisplayMessage
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "display-message"
type: |
  ~% (tS @-> tU)

params:
- str : string
code: |
  print_endline str;
  UnitConstant

---
inst: PrimitiveListCons
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
params:
- valuehd
- valuetl
code: |
  ListCons(valuehd, valuetl)

---
inst: PrimitiveSame
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "string-same"
type: |
  ~% (tS @-> tS @-> tB)

params:
- str1 : string
- str2 : string
code: |
  BooleanConstant(String.equal str1 str2)

---
inst: PrimitiveStringLessThan
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "string-lt"
type: |
  ~% (tS @-> tS @-> tB)

params:
- str1 : string
- str2 : string
code: |
  BooleanConstant(str1 < str2)

---
inst: PrimitiveStringSub
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "string-sub"
type: |
  ~% (tS @-> tI @-> tI @-> tS)

params:
- str : string
- pos : int
- wid : int
code: |
  let resstr =
  try BatUTF8.sub str pos wid with
  | Invalid_argument(s) -> report_dynamic_error "illegal index for string-sub"
  in
    StringConstant(resstr)

---
inst: PrimitiveStringSubBytes
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "string-sub-bytes"
type: |
  ~% (tS @-> tI @-> tI @-> tS)

params:
- str : string
- pos : int
- wid : int
code: |
  let resstr =
  try String.sub str pos wid with
  | Invalid_argument(s) -> report_dynamic_error "illegal index for string-sub-bytes"
  in
    StringConstant(resstr)

---
inst: PrimitiveStringLength
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "string-length"
type: |
  ~% (tS @-> tI)

params:
- str : string
code: |
  IntegerConstant(BatUTF8.length str)

---
inst: PrimitiveStringByteLength
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "string-byte-length"
type: |
  ~% (tS @-> tI)

params:
- str : string
code: |
  IntegerConstant(String.length str)

---
inst: PrimitiveStringScan
is-primitive: yes
name: "string-scan"
type: |
  ~% (tRE @-> tS @-> tOPT (tPROD [tS; tS]))

params:
- pat : regexp
- str : string
code: |
  if Str.string_match pat str 0 then
    let matched = Str.matched_string str in
    let start   = String.length matched in
    let rest    = String.sub str start (String.length str - start) in
    Constructor("Some", TupleCons(StringConstant(matched), TupleCons(StringConstant(rest), EndOfTuple)))
  else
    Constructor("None", UnitConstant)

---
inst: PrimitiveStringUnexplode
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "string-unexplode"
type: |
  ~% ((tL tI) @-> tS)

params:
- valueilst
code: |
  let ilst = get_list get_int valueilst in
  let s = (List.map Uchar.of_int ilst) |> InternalText.of_uchar_list |> InternalText.to_utf8 in
    StringConstant(s)

---
inst: PrimitiveRegExpOfString
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "regexp-of-string"
type: |
  ~% (tS @-> tRE)

params:
- str : string
code: |
  let regexp =
    try Str.regexp str with
    | Failure(msg) -> report_dynamic_error ("regexp-of-string: " ^ msg)
  in
    RegExpConstant(regexp)

---
inst: PrimitiveStringMatch
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "string-match"
type: |
  ~% (tRE @-> tS @-> tB)

params:
- pat : regexp
- s : string
code: |
  BooleanConstant(Str.string_match pat s 0)

---
inst: PrimitiveSplitIntoLines
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "split-into-lines"
type: |
  ~% (tS @-> (tL (tPROD [tI; tS])))

params:
- s : string
code: |
  let slst = String.split_on_char '\n' s in
  let pairlst = slst |> List.map chop_space_indent in
    (pairlst |> make_list (fun (i, s) ->
      TupleCons(IntegerConstant(i), TupleCons(StringConstant(s), EndOfTuple))))

---
inst: PrimitiveSplitOnRegExp
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "split-on-regexp"
type: |
  ~% (tRE @-> tS @-> (tL (tPROD [tI; tS])))

params:
- sep : regexp
- str : string
code: |
  let slst = Str.split sep str in
  let pairlst = slst |> List.map chop_space_indent in
    (pairlst |> make_list (fun (i, s) ->
      TupleCons(IntegerConstant(i), TupleCons(StringConstant(s), EndOfTuple))))

---
inst: PrimitiveArabic
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "arabic"
type: |
  ~% (tI @-> tS)

params:
- num : int
code: |
  StringConstant(string_of_int num)

---
inst: PrimitiveShowFloat
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "show-float"
type: |
  ~% (tFL @-> tS)

params:
- fl : float
code: |
  StringConstant(string_of_float fl)


---
inst: PrimitiveFloat
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "float"
type: |
  ~% (tI @-> tFL)

params:
- ic1 : int
code: |
  FloatConstant(float_of_int ic1)

---
inst: PrimitiveRound
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "round"
type: |
  ~% (tFL @-> tI)

params:
- fc1 : float
code: |
  IntegerConstant(int_of_float fc1)

---
inst: PrimitiveDrawText
is-pdf-mode-primitive: yes
name: "draw-text"
type: |
  ~% (tPT @-> tIB @-> tGR)

params:
- pt : point
- hblst : horz
code: |
  let (imhblst, _, _) = LineBreak.natural hblst in
  let grelem = GraphicD.make_text pt imhblst in
    GraphicsValue(grelem)

---
inst: PrimitiveDrawStroke
is-pdf-mode-primitive: yes
name: "stroke"
type: |
  ~% (tLN @-> tCLR @-> tPATH @-> tGR)

params:
- wid : length
- color : color
- pathlst : path_value
code: |
  let grelem = GraphicD.make_stroke wid color pathlst in
    GraphicsValue(grelem)

---
inst: PrimitiveDrawFill
is-pdf-mode-primitive: yes
name: "fill"
type: |
  ~% (tCLR @-> tPATH @-> tGR)

params:
- color : color
- pathlst : path_value
code: |
  let grelem = GraphicD.make_fill color pathlst in
    GraphicsValue(grelem)

---
inst: PrimitiveDrawDashedStroke
is-pdf-mode-primitive: yes
name: "dashed-stroke"
type: |
  ~% (tLN @-> tDASH @-> tCLR @-> tPATH @-> tGR)

params:
- wid : length
- valuetup3
- color : color
- pathlst : path_value
code: |
  let (len1, len2, len3) = get_tuple3 get_length valuetup3 in
  let grelem = GraphicD.make_dashed_stroke wid (len1, len2, len3) color pathlst in
    GraphicsValue(grelem)

---
inst: PrimitiveShiftGraphics
is-pdf-mode-primitive: yes
name: "shift-graphics"
type: |
  ~% (tPT @-> tGR @-> tGR)

params:
- vec : point
- grelem : graphics_element
code: |
  GraphicsValue(GraphicD.shift_element vec grelem)

---
inst: PrimtiveGetGraphicsBBox
is-pdf-mode-primitive: yes
name: get-graphics-bbox
type: |
  ~% (tGR @-> tPROD [tPT; tPT])

params:
- grelem : graphics_element
code: |
  let (ptmin, ptmax) =
    GraphicD.get_element_bbox (fun (x, y) imhblst ->
      let (wid, hgt, dpt) = HorzBox.get_metrics_of_intermediate_horz_box_list imhblst in
        ((x, y +% dpt), (x +% wid, y +% hgt))
    ) grelem
  in
    TupleCons(make_point_value ptmin,
      TupleCons(make_point_value ptmax,
        EndOfTuple))

---
inst: Times
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "*"
type: |
  ~% (tI @-> tI @-> tI)

params:
- numl : int
- numr : int
code: |
  IntegerConstant(numl * numr)

---
inst: Divides
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "/"
type: |
  ~% (tI @-> tI @-> tI)

params:
- numl : int
- numr : int
code: |
  try IntegerConstant(numl / numr) with
  | Division_by_zero -> report_dynamic_error "division by zero"

---
inst: Mod
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "mod"
type: |
  ~% (tI @-> tI @-> tI)

params:
- numl : int
- numr : int
code: |
  try IntegerConstant(numl mod numr) with
  | Division_by_zero -> report_dynamic_error "division by zero"

---
inst: Plus
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "+"
type: |
  ~% (tI @-> tI @-> tI)

params:
- numl : int
- numr : int
code: |
  IntegerConstant(numl + numr)

---
inst: Minus
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "-"
type: |
  ~% (tI @-> tI @-> tI)

params:
- numl : int
- numr : int
code: |
  IntegerConstant(numl - numr)

---
inst: EqualTo
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "=="
type: |
  ~% (tI @-> tI @-> tB)

params:
- numl : int
- numr : int
code: |
  BooleanConstant(numl = numr)

---
inst: GreaterThan
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: ">"
type: |
  ~% (tI @-> tI @-> tB)

params:
- numl : int
- numr : int
code: |
  BooleanConstant(numl > numr)

---
inst: LessThan
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "<"
type: |
  ~% (tI @-> tI @-> tB)

params:
- numl : int
- numr : int
code: |
  BooleanConstant(numl < numr)

---
inst: LogicalAnd
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "&&"
type: |
  ~% (tB @-> tB @-> tB)

params:
- binl : bool
- binr : bool
code: |
  BooleanConstant(binl && binr)

---
inst: LogicalOr
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "||"
type: |
  ~% (tB @-> tB @-> tB)

params:
- binl : bool
- binr : bool
code: |
  BooleanConstant(binl || binr)

---
inst: LogicalNot
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "not"
type: |
  ~% (tB @-> tB)

params:
- binl : bool
code: |
  BooleanConstant(not binl)

---
inst: FloatPlus
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "+."
type: |
  ~% (tFL @-> tFL @-> tFL)

params:
- flt1 : float
- flt2 : float
code: |
  FloatConstant(flt1 +. flt2)

---
inst: FloatMinus
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "-."
type: |
  ~% (tFL @-> tFL @-> tFL)

params:
- flt1 : float
- flt2 : float
code: |
  FloatConstant(flt1 -. flt2)

---
inst: FloatTimes
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "*."
type: |
  ~% (tFL @-> tFL @-> tFL)

params:
- flt1 : float
- flt2 : float
code: |
  FloatConstant(flt1 *. flt2)

---
inst: FloatDivides
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "/."
type: |
  ~% (tFL @-> tFL @-> tFL)

params:
- flt1 : float
- flt2 : float
code: |
  FloatConstant(flt1 /. flt2)

---
inst: FloatSine
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "sin"
type: |
  ~% (tFL @-> tFL)

params:
- flt1 : float
code: |
  FloatConstant(sin flt1)

---
inst: FloatArcSine
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "asin"
type: |
  ~% (tFL @-> tFL)

params:
- flt1 : float
code: |
  FloatConstant(asin flt1)

---
inst: FloatCosine
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "cos"
type: |
  ~% (tFL @-> tFL)

params:
- flt1 : float
code: |
  FloatConstant(cos flt1)

---
inst: FloatArcCosine
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "acos"
type: |
  ~% (tFL @-> tFL)

params:
- flt1 : float
code: |
  FloatConstant(acos flt1)

---
inst: FloatTangent
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "tan"
type: |
  ~% (tFL @-> tFL)

params:
- flt1 : float
code: |
  FloatConstant(tan flt1)

---
inst: FloatArcTangent
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "atan"
type: |
  ~% (tFL @-> tFL)

params:
- flt1 : float
code: |
  FloatConstant(atan flt1)

---
inst: FloatArcTangent2
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "atan2"
type: |
  ~% (tFL @-> tFL @-> tFL)

params:
- flt1 : float
- flt2 : float
code: |
  FloatConstant(atan2 flt1 flt2)

---
inst: LengthPlus
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "+'"
type: |
  ~% (tLN @-> tLN @-> tLN)

params:
- len1 : length
- len2 : length
code: |
  LengthConstant(HorzBox.(len1 +% len2))

---
inst: LengthMinus
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "-'"
type: |
  ~% (tLN @-> tLN @-> tLN)

params:
- len1 : length
- len2 : length
code: |
  LengthConstant(HorzBox.(len1 -% len2))

---
inst: LengthTimes
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "*'"
type: |
  ~% (tLN @-> tFL @-> tLN)

params:
- len1 : length
- flt2 : float
code: |
  LengthConstant(HorzBox.(len1 *% flt2))

---
inst: LengthDivides
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "/'"
type: |
  ~% (tLN @-> tLN @-> tFL)

params:
- len1 : length
- len2 : length
code: |
  FloatConstant(HorzBox.(len1 /% len2))

---
inst: LengthLessThan
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "<'"
type: |
  ~% (tLN @-> tLN @-> tB)

params:
- len1 : length
- len2 : length
code: |
  BooleanConstant(HorzBox.(len1 <% len2))

---
inst: LengthGreaterThan
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: ">'"
type: |
  ~% (tLN @-> tLN @-> tB)

params:
- len1 : length
- len2 : length
code: |
  BooleanConstant(HorzBox.(len2 <% len1))

---
inst: InsertArgs
fields:
- lst : syntactic_value list
params:
- func
code : |
  exec (func :: (List.rev_append lst stack)) env code dump

---
inst: PrimitiveSetWordBreakPenalty
is-pdf-mode-primitive: yes
name: "set-word-break-penalty"
type: |
  ~% (tI @-> tCTX @-> tCTX)

params:
- pnlty : int
- (ctx, valuecmd) : context
code: |
  Context(HorzBox.{ ctx with
    space_badness = pnlty;
  }, valuecmd)

---
inst: PrimitiveSetEveryWordBreak
is-pdf-mode-primitive: yes
name: "set-every-word-break"
type: |
  ~% (tIB @-> tIB @-> tCTX @-> tCTX)

params:
- hblst1 : horz
- hblst2 : horz
- (ctx, valuecmd) : context
code: |
  Context(HorzBox.({ ctx with
    before_word_break = hblst1;
    after_word_break = hblst2;
  }), valuecmd)

---
inst: PrimitiveGetEveryWordBreak
is-pdf-mode-primitive: yes
name: "get-every-word-break"
type: |
  ~% (tCTX @-> tPROD [tIB; tIB])

params:
- (ctx, _) : context
code: |
  let hblst1 = ctx.HorzBox.before_word_break in
  let hblst2 = ctx.HorzBox.after_word_break in
    TupleCons(Horz(hblst1), TupleCons(Horz(hblst2), EndOfTuple))

---
inst: BackendProbeCrossReference
is-pdf-mode-primitive : yes
name: "probe-cross-reference"
type: |
  ~% (tS @-> (tOPT tS))

params:
- k : string
code: |
  match CrossRef.probe k with
  | None    -> Constructor("None", UnitConstant)
  | Some(v) -> Constructor("Some", StringConstant(v))

---
inst: BackendRegisterDestination
is-pdf-mode-primitive: yes
name: "register-destination"
type: |
  ~% (tS @-> tPT @-> tU)

params:
- name : string
- p : point

code: |
  NamedDest.register name p;
  UnitConstant

---
inst: BackendRegisterLinkToUri
is-pdf-mode-primitive: yes
name: "register-link-to-uri"
type: |
  ~% (tS @-> tPT @-> tLN @-> tLN @-> tLN @-> (tOPT (tPROD [tLN; tCLR])) @-> tU)

params:
- uri : string
- pt : point
- wid : length
- hgt : length
- dpt : length
- vborderopt

code: |
  let borderopt = get_option (get_pair get_length get_color) vborderopt in
  Annotation.register (Annotation.Link(Action.Uri(uri))) (pt, wid, hgt, dpt) borderopt;
  UnitConstant

---
inst: BackendRegisterLinkToLocation
is-pdf-mode-primitive: yes
name: "register-link-to-location"
type: |
  ~% (tS @-> tPT @-> tLN @-> tLN @-> tLN @-> (tOPT (tPROD [tLN; tCLR])) @-> tU)

params:
- name : string
- pt : point
- wid : length
- hgt : length
- dpt : length
- vborderopt

code: |
  let borderopt = get_option (get_pair get_length get_color) vborderopt in
  let destname = NamedDest.get name in
  Annotation.register (Annotation.Link(Action.GotoName(destname))) (pt, wid, hgt, dpt) borderopt;
  UnitConstant

---
inst: BackendRegisterOutline
is-pdf-mode-primitive : yes
name: "register-outline"
type: |
  ~% ((tL(tPROD [tI; tS; tS; tB])) @-> tU)
params:
  - ol
code: |
  Outline.register (get_list get_outline ol);
  UnitConstant
